{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///Users/dasmesh/Documents/Git%20Hub/dropship-store/lib/firebase.ts"],"sourcesContent":["import { initializeApp, getApps } from 'firebase/app';\nimport { getAuth } from 'firebase/auth';\nimport { getFirestore } from 'firebase/firestore';\n\nconst firebaseConfig = {\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n    measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,\n};\n\n// Initialize Firebase\nconst app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];\nconst auth = getAuth(app);\nconst db = getFirestore(app);\n\nexport { app, auth, db };\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEA,MAAM,iBAAiB;IACnB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;IACL,aAAa;AACjB;AAEA,sBAAsB;AACtB,MAAM,MAAM,IAAA,6KAAO,IAAG,MAAM,KAAK,IAAI,IAAA,mLAAa,EAAC,kBAAkB,IAAA,6KAAO,GAAE,CAAC,EAAE;AACjF,MAAM,OAAO,IAAA,+KAAO,EAAC;AACrB,MAAM,KAAK,IAAA,mLAAY,EAAC"}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///Users/dasmesh/Documents/Git%20Hub/dropship-store/app/api/products/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { db } from '@/lib/firebase';\nimport { collection, getDocs, query, orderBy, limit, startAfter, where, doc, getDoc } from 'firebase/firestore';\n\n// GET: List all products with pagination and filtering\nexport async function GET(request: NextRequest) {\n    try {\n        const searchParams = request.nextUrl.searchParams;\n        const pageSize = parseInt(searchParams.get('limit') || '20');\n        const status = searchParams.get('status');\n        const category = searchParams.get('category');\n        const search = searchParams.get('search');\n\n        let q = query(\n            collection(db, 'products'),\n            orderBy('createdAt', 'desc'),\n            limit(pageSize)\n        );\n\n        // Apply filters\n        if (status && status !== 'all') {\n            q = query(\n                collection(db, 'products'),\n                where('status', '==', status),\n                orderBy('createdAt', 'desc'),\n                limit(pageSize)\n            );\n        }\n\n        if (category && category !== 'all') {\n            q = query(\n                collection(db, 'products'),\n                where('category', '==', category),\n                orderBy('createdAt', 'desc'),\n                limit(pageSize)\n            );\n        }\n\n        const snapshot = await getDocs(q);\n\n        let products = snapshot.docs.map(doc => ({\n            id: doc.id,\n            ...doc.data(),\n            createdAt: doc.data().createdAt?.toDate?.()?.toISOString() || null,\n            updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString() || null,\n        }));\n\n        // Client-side search filter (for now - could be improved with Algolia/ElasticSearch)\n        if (search) {\n            const searchLower = search.toLowerCase();\n            products = products.filter(p =>\n                p.name?.toLowerCase().includes(searchLower) ||\n                p.sku?.toLowerCase().includes(searchLower)\n            );\n        }\n\n        // Get total count (approximate for now)\n        const countSnapshot = await getDocs(collection(db, 'products'));\n        const totalCount = countSnapshot.size;\n\n        return NextResponse.json({\n            success: true,\n            data: {\n                products,\n                totalCount,\n                pageSize,\n            },\n        });\n    } catch (error) {\n        console.error('Error fetching products:', error);\n        return NextResponse.json(\n            {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to fetch products'\n            },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;;;;AAGO,eAAe,IAAI,OAAoB;IAC1C,IAAI;QACA,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,WAAW,SAAS,aAAa,GAAG,CAAC,YAAY;QACvD,MAAM,SAAS,aAAa,GAAG,CAAC;QAChC,MAAM,WAAW,aAAa,GAAG,CAAC;QAClC,MAAM,SAAS,aAAa,GAAG,CAAC;QAEhC,IAAI,IAAI,IAAA,4KAAK,EACT,IAAA,iLAAU,EAAC,uHAAE,EAAE,aACf,IAAA,8KAAO,EAAC,aAAa,SACrB,IAAA,4KAAK,EAAC;QAGV,gBAAgB;QAChB,IAAI,UAAU,WAAW,OAAO;YAC5B,IAAI,IAAA,4KAAK,EACL,IAAA,iLAAU,EAAC,uHAAE,EAAE,aACf,IAAA,4KAAK,EAAC,UAAU,MAAM,SACtB,IAAA,8KAAO,EAAC,aAAa,SACrB,IAAA,4KAAK,EAAC;QAEd;QAEA,IAAI,YAAY,aAAa,OAAO;YAChC,IAAI,IAAA,4KAAK,EACL,IAAA,iLAAU,EAAC,uHAAE,EAAE,aACf,IAAA,4KAAK,EAAC,YAAY,MAAM,WACxB,IAAA,8KAAO,EAAC,aAAa,SACrB,IAAA,4KAAK,EAAC;QAEd;QAEA,MAAM,WAAW,MAAM,IAAA,8KAAO,EAAC;QAE/B,IAAI,WAAW,SAAS,IAAI,CAAC,GAAG,CAAC,CAAA,MAAO,CAAC;gBACrC,IAAI,IAAI,EAAE;gBACV,GAAG,IAAI,IAAI,EAAE;gBACb,WAAW,IAAI,IAAI,GAAG,SAAS,EAAE,YAAY,iBAAiB;gBAC9D,WAAW,IAAI,IAAI,GAAG,SAAS,EAAE,YAAY,iBAAiB;YAClE,CAAC;QAED,qFAAqF;QACrF,IAAI,QAAQ;YACR,MAAM,cAAc,OAAO,WAAW;YACtC,WAAW,SAAS,MAAM,CAAC,CAAA,IACvB,EAAE,IAAI,EAAE,cAAc,SAAS,gBAC/B,EAAE,GAAG,EAAE,cAAc,SAAS;QAEtC;QAEA,wCAAwC;QACxC,MAAM,gBAAgB,MAAM,IAAA,8KAAO,EAAC,IAAA,iLAAU,EAAC,uHAAE,EAAE;QACnD,MAAM,aAAa,cAAc,IAAI;QAErC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,MAAM;gBACF;gBACA;gBACA;YACJ;QACJ;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACpB;YACI,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}